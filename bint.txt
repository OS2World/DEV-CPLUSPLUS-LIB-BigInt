*****************************
**                         **
** BINT - Big INTeger math **
**                         **
*****************************

DESCRIPTION
     Bint is a library of function to manipulate big integers.
     Why use a special library when we have longs, doubles or even
     long doubles? Because the built-in types in C has limits.
     I was planning to program a RSA en/de-cryption tool. To
     encrypt data it was needed to to raise a number to a power
     and the do a modulus division. Well, you could have done
     that with normal longs, you might say - No I could not! The
     RSA standard requires the power to be a 100-digit number
     and the divisor to be a 200-digit number! this was too much
     for even long doubles.

     So I began programming the BINT library.

     All the function in the library uses a "bint" type. The
     bint type is defined in bint.h and all the functions are in
     bint.c

     Why, you might ask, is the bint not a class. I made the 
     decision to make bint a normal abstract data type due to 
     the fact that not everybody have a C++ compiler.

     You can change the size of the bint type, you do this by
     changing the #define's BINT_xxxxxxx. Note that when you
     change the BINT_ELEMTYPE yu must change BINT_ELEM_BITS too.
     The type defined by BINT_ELEMTYPE can be all unsigned
     datatypes. By default the type is unsigned char and the
     number of element in a bint is 16.
     This gives the bint a size of 128 bits. The precision is
     approx. 38 digits (decimal) so if you need more can
     increase BINT_ELEMENTS or change BINT_ELEMTYPE to a bigger
     data type (note: the type must be unsigned).


DECRIPTION OF FUNCTIONS
     All the functions have been programmed to give optimum
     performance (as algorithms, -not code). This has been done
     using formal methods.The register keyword have not been used
     due to the fact that most modern C-compilers does this
     automatically.

     All the functions take pointers to bint as arguments.
     Most of the functions returns a pointer to the result (NULL
     if an error occurred). This makes it possible to make
     statements like this:
	  bint_inc(bint_mul(&a,bint_add(&b,&c)));
	  /* equivalent to result=a*(b+c)+1;

     Overflow (and underflow) is not detected;


     Each function is described by:
	Prototype:
	   eg. bint *bint_inc(bit *result);
	Pre:
	   Any preconditions
	Post:
	   Postcondition (what the function establishes)
	Time complexity:
	   Abstract time use:
	     O(1)        constant time use
	     O(a)        time use is propotional with a
	     O(log(a))   time use is propotional with log(a)
	     O(a*log(b)) time use is propotional with a*log(b)
	A description


Prototype:bint *uint_to_bint(unsigned int a,bint *result);
Pre:none
Post:result=a
Time complexity:O(1)
Converts an unsigned int to a bint. returns a pointer to result


Prototype:bint *long_to_bint(long a,bint *result);
Pre:none
Post:result=a
Time complexity:O(1)
Converts a long to a bint. returns a pointer to result


Prototype:bint *double_to_bint(double a,bint *result);
Pre:none
Post:result=a
Time complexity:(1)
Converts a double to a bint. returns a pointer to result. If you call this
function with a negative double you get funny results!


Prototype:unsigned int bint_to_uint(bint *a);
Pre:none
Post:returns bint as int
Time complexity:O(1)
returns bint converted to a int. Overflow is not detected.


Prototype:long bint_to_long(bint *a);
Pre:none
Post:returns bint as long
Time complexity:O(1)
returns bint converted to a long. Overflow is not detected.


Prototype:double bint_to_double(bint *a);
Pre:none
Post:returns bint as double
Time complexity:O(1)
returns bint converted to a double. Overflow is not detected. It is possible
to detect this by a matherr()


Prototype:bint *bint_inc(bint *result);
Pre:none
Post:result'=result+1
Time complexity:O(1)
Increases result by 1. Is equivalent to the C operator ++. No overflow detect


Prototype:bint *bint_dec(bint *result);
Pre:none
Post:result'=result-1
Time complexity:O(1)
Decreases result by 1. Is equivalent to the C operator ++. No overflow detect


Prototype:bint *bint_complement1(bint *a,bint *result);
Pre:none
Post:result= 1-complement of a
Time complexity:O(1)
Computes the 1-complement of a. A 1-complement is a number with all the bits
toggled. Used for subtraction.


Prototype:bint *bint_complement2(bint *a,bint *result);
Pre:none
Post:result= 2-complement of a
Time complexity:O(1)
Computes the 2-complement of a. A 2-complement is a 1-complement plus 1


Prototype:bint *bint_add(bint *a,bint *b,bint *result);
Pre:none
Post:result= a+b
Time complexity:O(1)
Adds a and b giving result


Prototype:bint *bint_sub(bint *a,bint *b,bint *result);
Pre:none
Post:result= a-b
Time complexity:O(1)
Substracts b from a giving result


Prototype:bint *bint_div2(bint *a,bint *result);
Pre:none
Post:result= a/2
Time complexity:O(1)
Divides a by 2 giving result. Equivalent to a right-shift


Prototype:bint *bint_mod2(bint *a,bint *result);
Pre:none
Post:result = a mod 2
Time complexity:O(1)
returns the remainder when a is divided by 2


Prototype:bint *bint_mul2(bint *a,bint *result);
Pre:none
Post:result= a*2
Time complexity:O(1)
Multiplies a with 2 giving result. Equivalent to a left-shift.


Prototype:int bint_is_zero(bint *a);
Pre:none
Post: return wether or not a is zero
Time complexity:O(1);

Prototype:int bint_cmp(bint *a,bint *b);
Pre:none
Post:returns a<b -> -1
	     a=b ->  0
	     a>b ->  1
Time complexity:O(1)
Compares a with b returning the result of the comparision. Works just like
strcmp() and is therefor compatible with qsort()


Prototype:void bint_divmod(bint *A,bint *B,bint *result1,bint *result2);
Pre:B<>0
Post:result1*B+result2=A
Time complexity:O(log(B))
Divides A with B giving the quotient in result1 and the remainder in result2


Prototype:bint *bint_div(bint *a,bint *b,bint *result);
Pre:b<>0
Post:result=a/b
Time complexity:O(log(b))
Divides a with b returning the quotient in result


Prototype:bint *bint_mod(bint *a,bint *b,bint *result);
Pre:b<>0
Post:result= a mod b
Time complexity:O(log(b))
Divides a with b returning the remander in result


Prototype:bint *bint_mul(bint *a,bint *b,bint *result);
Pre:none
Post:result= a*b
Time complexity:O(log(b))
Multiplies a with b giving result


Prototype:bint *bint_and(bint *a,bint *b,bint *result);
Pre:none
Post:result= a&b
Time complexity:O(1)
Performs a bit-wise AND on a and b giving result


Prototype:bint *bint_or(bint *a,bint *b,bint *result);
Pre:none
Post:result= a&b
Time complexity:O(1)
Performs a bit-wise AND on a and b giving result


Prototype:bint *bint_xor(bint *a,bint *b,bint *result);
Pre:none
Post:result= a|b
Time complexity:O(1)
Performs a bit-wise AND on a and b giving result


Prototype:bint *bint_setbit(bint *a,int bitno);
Pre:none
Post:bit (bitno) is set in a
Time complexity:O(1)
Sets the bitno'th bit in a. Ignores bitno's below 0 and above
BINT_ELEMENTS*BINT_ELEM_BITS


Prototype:bint *bint_resetbit(bint *a,int bitno);
Pre:none
Post:bit (bitno) is reset in a
Time complexity:O(1)
Resets the bitno'th bit in a. Ignores bitno's below 0 and above
BINT_ELEMENTS*BINT_ELEM_BITS


Prototype:int bint_getbit(bint *a,int bitno);
Pre:none
Post:returns the bitno'th bit in a
Time complexity:O(1)
Returns the bitno'th bit in a. Returns 0 when bitno is below 0 or above
BINT_ELEMENTS*BINT_ELEM_BITS


Prototype:char *bint_to_string(bint *a,char *s);
Pre:none
Post:
Time complexity:O(log10(a))
Writes a decimal representation of a in the string s. s should be at least
BINT_ELEMENTS*BINT_ELEM_BITS/ln(10)/ln(2) +1 to avoid writing out of the
allocated space. For BINT_ELEMENTS=16 and BINT_ELEM_BITS=8. total bits is 128
128/ln(10)/ln(2) = 128/3 = approx. 38 bytes


Prototype:bint *bint_gcd(bint *a,bint *b,bint *result);
Pre:(a<>0 & b<>0)
Post:result= greatest common divisor of a and b
Time complexity:worst-case is ((a/b) max (b/a))
Returns the gratest common divisor of a and b.
ie: 7 gcd 9   = 1
    9 gcd 15  = 3
    12 gcd 24 = 12
    0 gcd 29  = 0!!!
    12 gcd 12 = 12



Prototype:bint *bint_log2(bint *a,bint *result);
Pre:none
Post:2^result >=a
Time complexity:O(1)
Returns the 2-logarithm of a rounded up


Prototype:bint *bint_sqrt(bint *a,bint *result);
Pre:none
Post:result*result<=a & (result+1)*(result+1)>a
Time complexity:O(log(a))
Returns the square root of a rounded down.


Prototype:bint *bint_pow(bint *a,bint *b,bint *result);
Pre:none
Post:result= a^b
Time complexity:O(log(b))
Raises a to the power of b giving result


Prototype:bint *bint_powmod(bint *a,bint *b,bint *c,bint *result);
Pre:c<>0
Post:result= a^b mod c
Time complexity:I dont know!
Raises a to the power of b, divides the result by c and returns the
remainder in result.
This is actually the en-/decryption in the RSA method.


